from __future__ import annotations

"""
=============================================================================
BESIKTNINGSAPP BACKEND - BASE MODEL
=============================================================================
Base model class with common fields for all entities.

Provides:
- Primary key (id)
- Client ID (UUID from mobile client for offline-first sync)
- Revision (for optimistic locking and conflict detection)
- Timestamps (created_at, updated_at)
"""

from datetime import datetime
from typing import Any, Dict
from uuid import UUID

from sqlalchemy import Column, Integer, String, DateTime, event
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.ext.declarative import declared_attr

from app.extensions import db


class BaseModel(db.Model):
    """
    Base model with common fields for all entities.
    
    Attributes:
        id: Server-generated primary key
        client_id: UUID generated by client (for offline-first mapping)
        revision: Version number (increments on each update, for conflict detection)
        created_at: Timestamp when entity was created
        updated_at: Timestamp when entity was last updated
    """
    
    __abstract__ = True
    
    # Primary key
    id = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
        nullable=False,
    )
    
    # Client-generated UUID (for offline-first sync)
    client_id = Column(
        PGUUID(as_uuid=True),
        unique=True,
        nullable=True,
        index=True,
        comment="UUID generated by client for offline-first sync",
    )
    
    # Revision for optimistic locking
    revision = Column(
        Integer,
        nullable=False,
        default=1,
        comment="Version number for optimistic locking",
    )
    
    # Timestamps
    created_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        comment="Timestamp when entity was created (UTC)",
    )
    
    updated_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment="Timestamp when entity was last updated (UTC)",
    )
    
    @declared_attr
    def __tablename__(cls) -> str:
        """
        Generate table name from class name.
        Converts CamelCase to snake_case.
        """
        import re
        name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', cls.__name__)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', name).lower()
    
    def to_dict(self, include_relationships: bool = False) -> Dict[str, Any]:
        """
        Convert model instance to dictionary.
        
        Args:
            include_relationships: Whether to include relationship data
            
        Returns:
            Dictionary representation of the model
        """
        result = {}
        
        # Add columns
        for column in self.__table__.columns:
            value = getattr(self, column.name)
            
            # Convert UUID to string
            if isinstance(value, UUID):
                value = str(value)
            # Convert datetime to ISO format
            elif isinstance(value, datetime):
                value = value.isoformat()
            
            result[column.name] = value
        
        # Optionally add relationships
        if include_relationships:
            for relationship in self.__mapper__.relationships:
                value = getattr(self, relationship.key)
                if value is not None:
                    if isinstance(value, list):
                        result[relationship.key] = [
                            item.to_dict() if hasattr(item, 'to_dict') else str(item)
                            for item in value
                        ]
                    else:
                        result[relationship.key] = (
                            value.to_dict() if hasattr(value, 'to_dict') else str(value)
                        )
        
        return result
    
    def increment_revision(self) -> None:
        """Increment the revision number."""
        self.revision += 1
    
    def __repr__(self) -> str:
        """String representation of the model."""
        return f"<{self.__class__.__name__}(id={self.id}, revision={self.revision})>"


# =============================================================================
# EVENT LISTENERS
# =============================================================================

@event.listens_for(BaseModel, 'before_update', propagate=True)
def before_update_listener(mapper, connection, target):
    """
    Automatically increment revision on update.
    
    This ensures that every update increments the revision number,
    which is critical for conflict detection in offline-first sync.
    """
    target.increment_revision()


@event.listens_for(BaseModel, 'before_insert', propagate=True)
def before_insert_listener(mapper, connection, target):
    """
    Set initial values on insert.
    
    Ensures that revision starts at 1 and timestamps are set.
    """
    if target.revision is None:
        target.revision = 1
    
    if target.created_at is None:
        target.created_at = datetime.utcnow()
    
    if target.updated_at is None:
        target.updated_at = datetime.utcnow()
