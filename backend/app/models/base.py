from __future__ import annotations
"""
=============================================================================
BESIKTNINGSAPP BACKEND - BASE MODEL
=============================================================================
Base model class with common fields for all entities.

Provides:
- Primary key (id)
- Client ID (UUID from mobile client for offline-first sync)
- Revision (for optimistic locking and conflict detection)
- Timestamps (created_at, updated_at)
- Soft delete (deleted_at)
- Created by tracking (created_by_id)
"""
from datetime import datetime
from typing import Any, Dict
from uuid import UUID

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, event
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.ext.declarative import declared_attr

from app.extensions import db


class BaseModel(db.Model):
    """
    Base model with common fields for all entities.
    
    Attributes:
        id: Server-generated primary key
        client_id: UUID generated by client (for offline-first mapping)
        revision: Version number (increments on each update, for conflict detection)
        created_at: Timestamp when entity was created
        updated_at: Timestamp when entity was last updated
        deleted_at: Timestamp when entity was soft-deleted (NULL if not deleted)
        created_by_id: User ID who created this entity
    """
    
    __abstract__ = True
    
    # Primary key
    id = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
        nullable=False,
    )
    
    # Client-generated UUID (for offline-first sync)
    client_id = Column(
        PGUUID(as_uuid=True),
        unique=True,
        nullable=True,
        index=True,
        comment="UUID generated by client for offline-first sync",
    )
    
    # Revision for optimistic locking
    revision = Column(
        Integer,
        nullable=False,
        default=1,
        comment="Version number for optimistic locking",
    )
    
    # Timestamps
    created_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        comment="Timestamp when entity was created (UTC)",
    )
    
    updated_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment="Timestamp when entity was last updated (UTC)",
    )
    
    # Soft delete
    deleted_at = Column(
        DateTime,
        nullable=True,
        comment="Timestamp when entity was soft-deleted (UTC)",
    )
    
    # User tracking (optional - only for entities that should track creator)
    # Subclasses can override this
    @declared_attr
    def created_by_id(cls):
        """Foreign key to user who created this entity."""
        # Only add if the table needs it
        if hasattr(cls, '__track_creator__') and cls.__track_creator__:
            return Column(
                Integer,
                ForeignKey('users.id'),
                nullable=True,
                comment="User who created this entity",
            )
        return None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert model instance to dictionary."""
        data = {}
        for column in self.__table__.columns:
            value = getattr(self, column.name)
            # Handle UUID serialization
            if isinstance(value, UUID):
                value = str(value)
            # Handle datetime serialization
            elif isinstance(value, datetime):
                value = value.isoformat()
            data[column.name] = value
        return data
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<{self.__class__.__name__}(id={self.id})>"


# Event listener to set initial values
@event.listens_for(BaseModel, "before_insert", propagate=True)
def set_initial_values(mapper, connection, target):
    """
    Set initial values on insert.
    
    Ensures that revision starts at 1 and timestamps are set.
    """
    if target.revision is None:
        target.revision = 1
    if target.created_at is None:
        target.created_at = datetime.utcnow()
    if target.updated_at is None:
        target.updated_at = datetime.utcnow()
